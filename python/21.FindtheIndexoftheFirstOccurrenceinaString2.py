# Knuth-Morris-Pratt （KMP）算法
# 了解《部分匹配表》 Partial Match Table (PMT)
# 在了解它之前， 先了解何谓前缀和后缀
# "前缀"指除了最后一个字符以外，一个字符串的全部头部组合
# "后缀"指除了第一个字符以外，一个字符串的全部尾部组合
# 以"ABCDABD"为例
# －　"A"的前缀和后缀都为空集，共有元素的长度为0；
# －　"AB"的前缀为[A]，后缀为[B]，共有元素的长度为0；
# －　"ABC"的前缀为[A, AB]，后缀为[BC, C]，共有元素的长度0；
# －　"ABCD"的前缀为[A, AB, ABC]，后缀为[BCD, CD, D]，共有元素的长度为0；
# －　"ABCDA"的前缀为[A, AB, ABC, ABCD]，后缀为[BCDA, CDA, DA, A]，共有元素为"A"，长度为1；
# －　"ABCDAB"的前缀为[A, AB, ABC, ABCD, ABCDA]，后缀为[BCDAB, CDAB, DAB, AB, B]，共有元素为"AB"，长度为2；
# －　"ABCDABD"的前缀为[A, AB, ABC, ABCD, ABCDA, ABCDAB]，后缀为[BCDABD, CDABD, DABD, ABD, BD, D]，共有元素的长度为0。
# "部分匹配"的实质是，有时候，字符串头部和尾部会有重复。比如，"ABCDAB"之中有两个"AB"，那么它的"部分匹配值"就是2（"AB"的长度）。
# 搜索词移动的时候，第一个"AB"向后移动4位（字符串长度-部分匹配值），就可以来到第二个"AB"的位置。
# ------------------------------------------------------------------------------------------------------------------

# 现在正式进入流程
# 1. 首先，字符串"BBC ABCDAB ABCDABCDABDE"的第一个字符与搜索词"ABCDABD"的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。
# 2. 因为B与A不匹配，搜索词再往后移
# 3. 就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止
# 4. 接着比较字符串和搜索词的下一个字符，还是相同
# 5. 直到字符串有一个字符，与搜索词对应的字符不相同为止
# 6. 这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把"搜索位置"移到已经比较过的位置，重比一遍
# 7. 一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是"ABCDAB"。KMP算法的想法是，设法利用这个已知信息，不要把"搜索位置"移回已经比较过的位置，继续把它向后移，这样就提高了效率
# 8. 怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table)
# 9. 已知空格与D不匹配时，前面六个字符"ABCDAB"是匹配的。查表可知，最后一个匹配字符B对应的"部分匹配值"为2，因此按照下面的公式算出向后移动的位数：
# 移动位数 = 已匹配的字符数 - 对应的部分匹配值. 因为 6 - 2 等于4，所以将搜索词向后移动4位。
# 10. 因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（"AB"），对应的"部分匹配值"为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位
# 11. 因为空格与A不匹配，继续后移一位
# 12. 逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位
# 13. 逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        m, n = len(needle), len(haystack)

        if m == 0: return 0
        pi = [0] * m
        j = 0 # 判断重复字符串长度

        # 制作部分匹配表
        for i in range(1, m): # i从1开始，因为第一个永远是0，不需要被考虑
            # 这个while loop的示意图, (举个例子当i=5时)
            # [a, a, b, a, a, a, c]
            #          [a, a, b, a, a, a, c]
            # while loop 让 next数组重新开始和自己匹配
            # 如果相同则继续匹配，不重新开始
            while j > 0 and needle[i] != needle[j]:
                j = pi[j-1]
            if needle[i] == needle[j]:
                j += 1
            pi[i] = j
        print(pi)

        # KMP算法开始
        j = 0
        for i in range(n):
            while j > 0 and haystack[i] != needle[j]:
                j = pi[j-1] # 步骤基本和制作PMT一样
            if haystack[i] == needle[j]: # 若相等，则比较下一个字符
                j += 1
            if j == m: # 若完全匹配，则直接返回第一个出现的字符位置
                return i - m + 1
        return -1

sol = Solution()
print(sol.strStr("aabaaabaaac", "aabaaac"))